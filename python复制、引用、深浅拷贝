Python中，string、tuple和number是不可变对象，而list、dict等是可变对象，

对于变量（相对于“对象”），python函数参数传递有时是引用传递，有时是值传递。如果这个变量对应的对象值可变，就认为是引用，函数内外是同一个变量，如果这个变量对应的对象值不可改变，就认为是赋值，函数内外是不同的变量。
下面举例说明这两种对象对函数的参数传递的影响：
-----------------------------------
①
# 不可变对象 --> 赋值
def ChangeInt( a ):
    a = 10
nfoo = 2 
ChangeInt(nfoo)
print(nfoo) #结果是2
#传入函数的变量 a 可以认为是一个新的变量，与 nfoo 一同指向对象 2 ，后来  a = 10 ，让这个新的变量指向了对象10，由于是两个变量，函数里 a 的改变并没有改变 nfoo 的指向。
------------------------------------
②
# 可变对象 --> 引用
def ChangeList( a ):
    a[0] = 10
lstFoo = [2]
ChangeList(lstFoo )
print nfoo #结果是[10]
# 这里，a 和 lstFoo 是一个变量，函数内部的修改影响了函数外的变量。
------------------------------------
浅拷贝和深拷贝：
我们常用到的拷贝方式：

1）没有限制条件的分片表达式（L[:]）能够复制序列，但此法只能浅层复制。

2）字典 copy 方法，D.copy() 能够复制字典，但此法只能浅层复制

3）有些内置函数，例如 list，能够浅拷贝 list(L)

4）copy 标准库模块能够生成完整拷贝：deepcopy 本质上是递归 copy
浅拷贝属于“新瓶装旧酒”，即生成了一个新的变量，而变量所指向的对象和原来的是一样的：
l = ["hello", [2, 3, 4]]
id(l) # 3048239386824
[id(i) for i in l] # [1524761040, 1524761072]

k = l.copy()
id(k) # 3048239387080，地址不同，k是另一个变量
[id(i) for i in k] # [1524761040, 1524761072]，地址相同，指向同一个变量

深拷贝属于“新瓶装新酒”，即生成了一个新变量，指向和原对象相等的新对象（不可变对象除外）：
import copy

l = ["hello world", [2, 3, 4]]
id(l) # 3048239386824
[id(i) for i in l] # [3048239385040, 3048239387080]

k = copy.deepcopy(l)
id(k) # 3048240927048，地址不同，k是另一个变量
[id(i) for i in k]  # [3048239385040, 3048240927304]，字符串是不可变对象，所以仍指向原地址，对于list则分配了一片新的内存空间，只是值与原对象相同
--------------------------------------------------------
当list类型的对象进行append操作时，实际上追加的是该对象的引用。
import copy
a = [1, 2, 3, 4, ['a', 'b']] #原始对象
 
b = a                       #赋值，传对象的引用
c = copy.copy(a)            #对象拷贝，浅拷贝
d = copy.deepcopy(a)        #对象拷贝，深拷贝
 
a.append(5)                 #修改对象a
a[4].append('c')            #修改对象a中的['a', 'b']数组对象
 
print( 'a = ', a )
print( 'b = ', b )
print( 'c = ', c )
print( 'd = ', d )
得出的结果：
('a = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])
('b = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])
('c = ', [1, 2, 3, 4, ['a', 'b', 'c']])
('d = ', [1, 2, 3, 4, ['a', 'b']])
